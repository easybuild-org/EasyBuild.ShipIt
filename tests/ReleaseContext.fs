module EasyBuild.ShipIt.Tests.ReleaseContext

open VerifyTUnit
open TUnit.Core
open Tests.Utils
open EasyBuild.ShipIt.Generate
open EasyBuild.ShipIt.Generate.Types
open System.IO
open Semver
open EasyBuild.CommitParser
open EasyBuild.CommitParser.Types
open FsToolkit.ErrorHandling
open Spectre.Console.Cli
open Workspace
open EasyBuild.ShipIt.Types
open EasyBuild.ShipIt.Types.Settings
open SimpleExec

[<Literal>]
let STANDARD_CHANGELOG =
    """# Changelog

All notable changes to this project will be documented in this file.

This project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

This changelog is generated using [EasyBuild.ShipIt](https://github.com/easybuild-org/EasyBuild.ShipIt). Do not edit this file manually.

## 0.0.0

<!--
This version is here for programs like [EasyBuild.PackageReleaseNotes.Tasks](https://github.com/easybuild-org/EasyBuild.PackageReleaseNotes.Tasks)
to be able to build your project when working on the first version.
-->
"""

[<Category("ReleaseContext.compute")>]
type ComputeTests() =

    [<Test>]
    member _.``No version bump required if no commits``() =
        let defaultGenerateSettings =
            DefaultCommandSettings(GitRepositoryRoot = Workspace.``.``)

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata = ChangelogMetadata.Empty
            }

        let actual =
            ReleaseContext.compute
                defaultGenerateSettings
                changelogInfo
                []
                CommitParserConfig.Default

        Expect.equal actual (NoVersionBumpRequired changelogInfo)

    [<Test>]
    member _.``No version bump required if no commits have a suitable type``() =
        let defaultGenerateSettings =
            DefaultCommandSettings(GitRepositoryRoot = Workspace.``.``)

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata = ChangelogMetadata.Empty
            }

        let commits: Git.Commit list =
            [
                Git.Commit.Create(
                    "49c0699af98a67f1e8efcac8b1467b283a244aa8",
                    "chore: update dependencies"
                )
                Git.Commit.Create(
                    "43c60e4fc9585a9f235ab6a6dd97c4c1cf945e46",
                    "test: add a lot of tests"
                )
                Git.Commit.Create(
                    "f3c60e4fc9585a9f235ab6a6dd97c4c1cf945e46",
                    "style: fix formatting"
                )
                Git.Commit.Create(
                    "24da54e481726924b8cb03c28fe0821141883c28",
                    "refactor: refactor code"
                )
                Git.Commit.Create(
                    "e468776fc99ec895bf6942c8e2f16d02bbbd6e61",
                    "docs: update documentation"
                )
                Git.Commit.Create(
                    "95a0f02adc4a69e2d3f516cb11c1be8a4ef5c803",
                    "ci: update CI/CD configuration"
                )
            ]

        let actual =
            ReleaseContext.compute
                defaultGenerateSettings
                changelogInfo
                commits
                CommitParserConfig.Default

        Expect.equal actual (NoVersionBumpRequired changelogInfo)

    [<Test>]
    member _.``If commit is of type feat bump minor``() =

        let defaultGenerateSettings =
            DefaultCommandSettings(GitRepositoryRoot = Workspace.``.``)

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata = ChangelogMetadata.Empty
            }

        let commits: Git.Commit list =
            [
                Git.Commit.Create(
                    "49c0699af98a67f1e8efcac8b1467b283a244aa8",
                    "feat: add a new feature"
                )
            ]

        let actual =
            ReleaseContext.compute
                defaultGenerateSettings
                changelogInfo
                commits
                CommitParserConfig.Default

        let expected =
            {
                NewVersion = SemVersion(0, 1, 0)
                CommitsForRelease =
                    [
                        {
                            OriginalCommit = commits[0]
                            SemanticCommit =
                                Parser.tryParseCommitMessage
                                    CommitParserConfig.Default
                                    commits[0].RawBody
                                |> Result.valueOr failwith
                        }
                    ]
                LastCommitSha = "49c0699af98a67f1e8efcac8b1467b283a244aa8"
                Changelog = changelogInfo
            }
            |> BumpRequired

        Expect.equal actual expected

    [<Test>]
    member _.``If commit is of type perf bump minor``() =
        let defaultGenerateSettings =
            DefaultCommandSettings(GitRepositoryRoot = Workspace.``.``)

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata = ChangelogMetadata.Empty
            }

        let commits: Git.Commit list =
            [
                Git.Commit.Create(
                    "49c0699af98a67f1e8efcac8b1467b283a244aa8",
                    "perf: i am speed !!!"
                )
            ]

        let actual =
            ReleaseContext.compute
                defaultGenerateSettings
                changelogInfo
                commits
                CommitParserConfig.Default

        let expected =
            {
                NewVersion = SemVersion(0, 1, 0)
                CommitsForRelease =
                    [
                        {
                            OriginalCommit = commits[0]
                            SemanticCommit =
                                Parser.tryParseCommitMessage
                                    CommitParserConfig.Default
                                    commits[0].RawBody
                                |> Result.valueOr failwith
                        }
                    ]
                LastCommitSha = "49c0699af98a67f1e8efcac8b1467b283a244aa8"
                Changelog = changelogInfo
            }
            |> BumpRequired

        Expect.equal actual expected

    [<Test>]
    member _.``If commit is of type fix bump patch``() =
        let defaultGenerateSettings =
            DefaultCommandSettings(GitRepositoryRoot = Workspace.``.``)

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata = ChangelogMetadata.Empty
            }

        let commits: Git.Commit list =
            [ Git.Commit.Create("49c0699af98a67f1e8efcac8b1467b283a244aa8", "fix: fix a bug") ]

        let actual =
            ReleaseContext.compute
                defaultGenerateSettings
                changelogInfo
                commits
                CommitParserConfig.Default

        let expected =
            {
                NewVersion = SemVersion(0, 0, 1)
                CommitsForRelease =
                    [
                        {
                            OriginalCommit = commits[0]
                            SemanticCommit =
                                Parser.tryParseCommitMessage
                                    CommitParserConfig.Default
                                    commits[0].RawBody
                                |> Result.valueOr failwith
                        }
                    ]
                LastCommitSha = "49c0699af98a67f1e8efcac8b1467b283a244aa8"
                Changelog = changelogInfo
            }
            |> BumpRequired

        Expect.equal actual expected

    [<Test>]
    member _.``If force_version is set, use that version``() =
        let defaultGenerateSettings =
            DefaultCommandSettings(GitRepositoryRoot = Workspace.``.``)

        let changelogInfo =
            Workspace.Workspace.``valid_changelog_with_forced_version.md``
            |> FileInfo
            |> Changelog.tryLoad
            |> _.UnsafeOkValue

        let commits: Git.Commit list =
            [
                Git.Commit.Create(
                    "49c0699af98a67f1e8efcac8b1467b283a244aa8",
                    "feat: add a new feature"
                )
                Git.Commit.Create("43c60e4fc9585a9f235ab6a6dd97c4c1cf945e46", "fix: fix a bug")
            ]

        let actual =
            ReleaseContext.compute
                defaultGenerateSettings
                changelogInfo
                commits
                CommitParserConfig.Default

        match actual with
        | BumpRequired {
                           NewVersion = version
                       } -> Expect.equal version (SemVersion(42, 0, 0))
        | _ -> failwith "Expected BumpRequired"

    [<Test>]
    member _.``If --skip-invalid-commit is false, fail on invalid commit message``() =
        let settings =
            DefaultCommandSettings(
                SkipInvalidCommit = FlagValue(Value = false, IsSet = true),
                GitRepositoryRoot = Workspace.``.``
            )

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata = ChangelogMetadata.Empty
            }

        let commits: Git.Commit list =
            [
                Git.Commit.Create(
                    "49c0699af98a67f1e8efcac8b1467b283a244aa8",
                    "this is not a valid commit message"
                )
            ]

        Expect.throws (fun () ->
            ReleaseContext.compute settings changelogInfo commits CommitParserConfig.Default
            |> ignore
        )

    [<Test>]
    member _.``If --skip-invalid-commit is true, skip invalid commit messages``() =
        let defaultGenerateSettings =
            DefaultCommandSettings(
                SkipInvalidCommit = FlagValue(Value = true, IsSet = true),
                GitRepositoryRoot = Workspace.``.``
            )

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata = ChangelogMetadata.Empty
            }

        let commits: Git.Commit list =
            [
                Git.Commit.Create("49c0699af98a67f1e8efcac8b1467b283a244aa8", "fix: fix a bug")
                Git.Commit.Create(
                    "43c60e4fc9585a9f235ab6a6dd97c4c1cf945e46",
                    "this is not a valid commit message"
                )
            ]

        let actual =
            ReleaseContext.compute
                defaultGenerateSettings
                changelogInfo
                commits
                CommitParserConfig.Default

        let expected =
            {
                NewVersion = SemVersion(0, 0, 1)
                CommitsForRelease =
                    [
                        {
                            OriginalCommit = commits[0]
                            SemanticCommit =
                                Parser.tryParseCommitMessage
                                    CommitParserConfig.Default
                                    commits[0].RawBody
                                |> Result.valueOr failwith
                        }
                    ]
                LastCommitSha = "49c0699af98a67f1e8efcac8b1467b283a244aa8"
                Changelog = changelogInfo
            }
            |> BumpRequired

        Expect.equal actual expected

    [<Test>]
    member _.``If --skip-merge-commit is true, skip merge commits``() =
        let defaultGenerateSettings =
            DefaultCommandSettings(
                SkipMergeCommit = FlagValue(Value = true, IsSet = true),
                GitRepositoryRoot = Workspace.``.``
            )

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata = ChangelogMetadata.Empty
            }

        let commits: Git.Commit list =
            [
                Git.Commit.Create("49c0699af98a67f1e8efcac8b1467b283a244aa8", "fix: fix a bug")
                Git.Commit.Create(
                    "43c60e4fc9585a9f235ab6a6dd97c4c1cf945e46",
                    "Merge pull request #123 from feature/awesome-feature"
                )
                Git.Commit.Create(
                    "b7eafe7744e4738d9578c09e1d128bbb2f5c40d3",
                    "Merge branch 'develop' into feature/awesome-feature"
                )
            ]

        let actual =
            ReleaseContext.compute
                defaultGenerateSettings
                changelogInfo
                commits
                CommitParserConfig.Default

        let expected =
            {
                NewVersion = SemVersion(0, 0, 1)
                CommitsForRelease =
                    [
                        {
                            OriginalCommit = commits[0]
                            SemanticCommit =
                                Parser.tryParseCommitMessage
                                    CommitParserConfig.Default
                                    commits[0].RawBody
                                |> Result.valueOr failwith
                        }
                    ]
                LastCommitSha = "49c0699af98a67f1e8efcac8b1467b283a244aa8"
                Changelog = changelogInfo
            }
            |> BumpRequired

        Expect.equal actual expected

    [<Test>]
    member _.``If --skip-merge-commit is false, do not skip merge commits``() =
        let settings =
            DefaultCommandSettings(
                SkipMergeCommit = FlagValue(Value = false, IsSet = true),
                GitRepositoryRoot = Workspace.``.``
            )

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata = ChangelogMetadata.Empty
            }

        let commits: Git.Commit list =
            [
                Git.Commit.Create("49c0699af98a67f1e8efcac8b1467b283a244aa8", "fix: fix a bug")
                Git.Commit.Create(
                    "43c60e4fc9585a9f235ab6a6dd97c4c1cf945e46",
                    "Merge pull request #123 from feature/awesome-feature"
                )
            ]

        try
            ReleaseContext.compute settings changelogInfo commits CommitParserConfig.Default
            |> ignore

            failwith "Expected an exception to be thrown due to invalid commit message"
        with

        | :? FailedToParseCommit as ex ->
            Expect.equal
                ex.msg
                """Failed to parse commit message:

==============
Commit
==============

Merge pull request #123 from feature/awesome-feature

==============
Error
==============

Invalid commit message format.

Expected a commit message with the following format: '<type>[optional scope]: <description>'.

Where <type> is one of the following:

- feat: A new feature
- fix: A bug fix
- ci: Changes to CI/CD configuration
- chore: Changes to the build process or auxiliary tools and libraries such as documentation generation
- docs: Documentation changes
- test: Adding missing tests or correcting existing tests
- style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)
- refactor: A code change that neither fixes a bug nor adds a feature
- perf: A code change that improves performance
- revert: Reverts a previous commit
- build: Changes that affect the build system or external dependencies

Example:
-------------------------
feat: some description
-------------------------"""
        | ex -> failwith $"Unexpected exception: {ex}"

    [<Test>]
    member _.``Allows to include files from a parent directory``() =
        let defaultGenerateSettings =
            DefaultCommandSettings(GitRepositoryRoot = Workspace.``.``)

        let changelogInfo =
            {
                File = FileInfo(Workspace.``package-a``.``CHANGELOG.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 1, 0) ]
                Metadata =
                    { ChangelogMetadata.Empty with
                        Include = [ "../package-b/" ]
                    }
            }

        let commits: Git.Commit list =
            [
                Git.Commit.Create(
                    "49c0699af98a67f1e8efcac8b1467b283a244aa8",
                    "feat: add a new feature",
                    files = [ "package-b/somefile.txt" ]
                )
            ]

        let actual =
            ReleaseContext.compute
                defaultGenerateSettings
                changelogInfo
                commits
                CommitParserConfig.Default

        let expected =
            {
                NewVersion = SemVersion(0, 2, 0)
                CommitsForRelease =
                    [
                        {
                            OriginalCommit = commits[0]
                            SemanticCommit =
                                Parser.tryParseCommitMessage
                                    CommitParserConfig.Default
                                    commits[0].RawBody
                                |> Result.valueOr failwith
                        }
                    ]
                LastCommitSha = "49c0699af98a67f1e8efcac8b1467b283a244aa8"
                Changelog = changelogInfo
            }
            |> BumpRequired

        Expect.equal actual expected

    [<Test>]
    member _.``Allows to exclude files from a folder``() =
        let defaultGenerateSettings =
            DefaultCommandSettings(GitRepositoryRoot = Workspace.``.``)

        let changelogInfo =
            {
                File = FileInfo(Workspace.``package-a``.``CHANGELOG.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 1, 0) ]
                Metadata =
                    { ChangelogMetadata.Empty with
                        Exclude = [ "src/" ]
                    }
            }

        let commits: Git.Commit list =
            [
                Git.Commit.Create(
                    "49c0699af98a67f1e8efcac8b1467b283a244aa8",
                    "feat: add a new feature",
                    files = [ "package-a/src/somefile.txt" ]
                )
            ]

        let actual =
            ReleaseContext.compute
                defaultGenerateSettings
                changelogInfo
                commits
                CommitParserConfig.Default

        Expect.equal actual (NoVersionBumpRequired changelogInfo)

[<Category("ReleaseContext.computeVersion")>]
type ComputeVersionTests() =

    [<Test>]
    member _.``If previous version was a pre-release, release it as stable``() =
        let settings = DefaultCommandSettings()

        let commits: Git.Commit list =
            [ Git.Commit.Create("49c0699af98a67f1e8efcac8b1467b283a244aa8", "fix: fix a bug") ]

        let commits: CommitForRelease list =
            [
                {
                    OriginalCommit = commits[0]
                    SemanticCommit =
                        Parser.tryParseCommitMessage CommitParserConfig.Default commits[0].RawBody
                        |> Result.valueOr failwith
                }
            ]

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata = ChangelogMetadata.Empty
            }

        let actual =
            ReleaseContext.computeVersion
                settings
                changelogInfo
                commits
                (SemVersion(2, 0, 0).WithPrereleaseParsedFrom("beta.1"))

        Expect.equal actual (Some(SemVersion(2, 0, 0)))

    [<Test>]
    member _.``If user request a pre-release, should bump major and start a pre-release if previous version was stable and changes include breaking change``
        ()
        =
        let settings = DefaultCommandSettings()

        let commits: Git.Commit list =
            [ Git.Commit.Create("49c0699af98a67f1e8efcac8b1467b283a244aa8", "fix!: fix a bug") ]

        let commits: CommitForRelease list =
            [
                {
                    OriginalCommit = commits[0]
                    SemanticCommit =
                        Parser.tryParseCommitMessage CommitParserConfig.Default commits[0].RawBody
                        |> Result.valueOr failwith
                }
            ]

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata =
                    { ChangelogMetadata.Empty with
                        PreRelease = Some "beta"
                    }
            }

        let actual =
            ReleaseContext.computeVersion settings changelogInfo commits (SemVersion(2, 2, 45))

        Expect.equal actual (Some(SemVersion.ParsedFrom(3, 0, 0, "beta.1")))

    [<Test>]
    member _.``If user request a pre-release, should bump minor and make start a pre-release if previous version was stable and changes include new features``
        ()
        =
        let settings = DefaultCommandSettings()

        let commits: Git.Commit list =
            [
                Git.Commit.Create("49c0699af98a67f1e8efcac8b1467b283a244aa8", "fix: fix a bug")
                Git.Commit.Create(
                    "49c0699af98a67f1e8efcac8b1467b283a244aa7",
                    "feat: add a new feature"
                )
            ]

        let commits: CommitForRelease list =
            [
                {
                    OriginalCommit = commits[0]
                    SemanticCommit =
                        Parser.tryParseCommitMessage CommitParserConfig.Default commits[0].RawBody
                        |> Result.valueOr failwith
                }
                {
                    OriginalCommit = commits[1]
                    SemanticCommit =
                        Parser.tryParseCommitMessage CommitParserConfig.Default commits[1].RawBody
                        |> Result.valueOr failwith
                }
            ]

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata =
                    { ChangelogMetadata.Empty with
                        PreRelease = Some "beta"
                    }
            }

        let actual =
            ReleaseContext.computeVersion settings changelogInfo commits (SemVersion(2, 2, 45))

        Expect.equal actual (Some(SemVersion.ParsedFrom(2, 3, 0, "beta.1")))

    [<Test>]
    member _.``If user request a pre-release, should bump patch and make start a pre-release if previous version was stable and changes include only bug fixes``
        ()
        =
        let settings = DefaultCommandSettings()

        let commits: Git.Commit list =
            [
                Git.Commit.Create("49c0699af98a67f1e8efcac8b1467b283a244aa8", "fix: fix a bug")
                Git.Commit.Create(
                    "49c0699af98a67f1e8efcac8b1467b283a244aa7",
                    "fix: add a new feature"
                )
            ]

        let commits: CommitForRelease list =
            [
                {
                    OriginalCommit = commits[0]
                    SemanticCommit =
                        Parser.tryParseCommitMessage CommitParserConfig.Default commits[0].RawBody
                        |> Result.valueOr failwith
                }
                {
                    OriginalCommit = commits[1]
                    SemanticCommit =
                        Parser.tryParseCommitMessage CommitParserConfig.Default commits[1].RawBody
                        |> Result.valueOr failwith
                }
            ]

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata =
                    { ChangelogMetadata.Empty with
                        PreRelease = Some "beta"
                    }
            }

        let actual =
            ReleaseContext.computeVersion settings changelogInfo commits (SemVersion(2, 2, 45))

        Expect.equal actual (Some(SemVersion.ParsedFrom(2, 2, 46, "beta.1")))

    [<Test>]
    member _.``If user request a pre-release, should increment the pre-release number if previous version was a pre-release (check for major version)``
        ()
        =
        let settings = DefaultCommandSettings()

        let commits: Git.Commit list =
            [ Git.Commit.Create("49c0699af98a67f1e8efcac8b1467b283a244aa8", "fix!: fix a bug") ]

        let commits: CommitForRelease list =
            [
                {
                    OriginalCommit = commits[0]
                    SemanticCommit =
                        Parser.tryParseCommitMessage CommitParserConfig.Default commits[0].RawBody
                        |> Result.valueOr failwith
                }
            ]

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata =
                    { ChangelogMetadata.Empty with
                        PreRelease = Some "beta"
                    }
            }

        let actual =
            ReleaseContext.computeVersion
                settings
                changelogInfo
                commits
                (SemVersion.ParsedFrom(3, 0, 0, "beta.10"))

        Expect.equal actual (Some(SemVersion.ParsedFrom(3, 0, 0, "beta.11")))

    [<Test>]
    member _.``If user request a pre-release, should increment the pre-release number if previous version was a pre-release (check for minor version)``
        ()
        =
        let settings = DefaultCommandSettings()

        let commits: Git.Commit list =
            [
                Git.Commit.Create("49c0699af98a67f1e8efcac8b1467b283a244aa8", "fix: fix a bug")
                Git.Commit.Create(
                    "49c0699af98a67f1e8efcac8b1467b283a244aa7",
                    "feat: add a new feature"
                )
            ]

        let commits: CommitForRelease list =
            [
                {
                    OriginalCommit = commits[0]
                    SemanticCommit =
                        Parser.tryParseCommitMessage CommitParserConfig.Default commits[0].RawBody
                        |> Result.valueOr failwith
                }
                {
                    OriginalCommit = commits[1]
                    SemanticCommit =
                        Parser.tryParseCommitMessage CommitParserConfig.Default commits[1].RawBody
                        |> Result.valueOr failwith
                }
            ]

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata =
                    { ChangelogMetadata.Empty with
                        PreRelease = Some "beta"
                    }
            }

        let actual =
            ReleaseContext.computeVersion
                settings
                changelogInfo
                commits
                (SemVersion.ParsedFrom(2, 2, 0, "beta.233"))

        Expect.equal actual (Some(SemVersion.ParsedFrom(2, 2, 0, "beta.234")))

    [<Test>]
    member _.``If user request a pre-release, should increment the pre-release number if previous version was a pre-release (check for patch version)``
        ()
        =
        let settings = DefaultCommandSettings()

        let commits: Git.Commit list =
            [
                Git.Commit.Create("49c0699af98a67f1e8efcac8b1467b283a244aa8", "fix: fix a bug")
                Git.Commit.Create(
                    "49c0699af98a67f1e8efcac8b1467b283a244aa7",
                    "fix: add a new feature"
                )
            ]

        let commits: CommitForRelease list =
            [
                {
                    OriginalCommit = commits[0]
                    SemanticCommit =
                        Parser.tryParseCommitMessage CommitParserConfig.Default commits[0].RawBody
                        |> Result.valueOr failwith
                }
                {
                    OriginalCommit = commits[1]
                    SemanticCommit =
                        Parser.tryParseCommitMessage CommitParserConfig.Default commits[1].RawBody
                        |> Result.valueOr failwith
                }
            ]

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata =
                    { ChangelogMetadata.Empty with
                        PreRelease = Some "beta"
                    }
            }

        let actual =
            ReleaseContext.computeVersion
                settings
                changelogInfo
                commits
                (SemVersion.ParsedFrom(2, 2, 45, "beta.5"))

        Expect.equal actual (Some(SemVersion.ParsedFrom(2, 2, 45, "beta.6")))

    [<Test>]
    member _.``If previous version was a pre-release, and user don't request a pre-release, release it as stable (check for major version)``
        ()
        =
        let settings = DefaultCommandSettings()

        let commits: Git.Commit list =
            [ Git.Commit.Create("49c0699af98a67f1e8efcac8b1467b283a244aa8", "fix!: fix a bug") ]

        let commits: CommitForRelease list =
            [
                {
                    OriginalCommit = commits[0]
                    SemanticCommit =
                        Parser.tryParseCommitMessage CommitParserConfig.Default commits[0].RawBody
                        |> Result.valueOr failwith
                }
            ]

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata = ChangelogMetadata.Empty
            }

        let actual =
            ReleaseContext.computeVersion
                settings
                changelogInfo
                commits
                (SemVersion(2, 0, 0).WithPrereleaseParsedFrom("beta.1"))

        Expect.equal actual (Some(SemVersion(2, 0, 0)))

    [<Test>]
    member _.``If previous version was a pre-release, and user don't request a pre-release, release it as stable (check for minor version)``
        ()
        =
        let settings = DefaultCommandSettings()

        let commits: Git.Commit list =
            [ Git.Commit.Create("49c0699af98a67f1e8efcac8b1467b283a244aa8", "feat: fix a bug") ]

        let commits: CommitForRelease list =
            [
                {
                    OriginalCommit = commits[0]
                    SemanticCommit =
                        Parser.tryParseCommitMessage CommitParserConfig.Default commits[0].RawBody
                        |> Result.valueOr failwith
                }
            ]

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata = ChangelogMetadata.Empty
            }

        let actual =
            ReleaseContext.computeVersion
                settings
                changelogInfo
                commits
                (SemVersion(2, 0, 0).WithPrereleaseParsedFrom("beta.1"))

        Expect.equal actual (Some(SemVersion(2, 0, 0)))

    [<Test>]
    member _.``If previous version was a pre-release, and user don't request a pre-release, release it as stable (check for patch version)``
        ()
        =
        let settings = DefaultCommandSettings()

        let commits: Git.Commit list =
            [ Git.Commit.Create("49c0699af98a67f1e8efcac8b1467b283a244aa8", "fix: fix a bug") ]

        let commits: CommitForRelease list =
            [
                {
                    OriginalCommit = commits[0]
                    SemanticCommit =
                        Parser.tryParseCommitMessage CommitParserConfig.Default commits[0].RawBody
                        |> Result.valueOr failwith
                }
            ]

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata = ChangelogMetadata.Empty
            }

        let actual =
            ReleaseContext.computeVersion
                settings
                changelogInfo
                commits
                (SemVersion(2, 0, 0).WithPrereleaseParsedFrom("beta.1"))

        Expect.equal actual (Some(SemVersion(2, 0, 0)))

    [<Test>]
    member _.``If pre-release identifier is different start a new pre-release from 1 (check for major)``
        ()
        =
        let settings = DefaultCommandSettings()

        let commits: Git.Commit list =
            [ Git.Commit.Create("49c0699af98a67f1e8efcac8b1467b283a244aa8", "fix: fix a bug") ]

        let commits: CommitForRelease list =
            [
                {
                    OriginalCommit = commits[0]
                    SemanticCommit =
                        Parser.tryParseCommitMessage CommitParserConfig.Default commits[0].RawBody
                        |> Result.valueOr failwith
                }
            ]

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata =
                    { ChangelogMetadata.Empty with
                        PreRelease = Some "alpha"
                    }
            }

        let actual =
            ReleaseContext.computeVersion
                settings
                changelogInfo
                commits
                (SemVersion(2, 0, 0).WithPrereleaseParsedFrom("beta.10"))

        Expect.equal actual (Some(SemVersion.ParsedFrom(2, 0, 0, "alpha.1")))

    [<Test>]
    member _.``If pre-release identifier is different start a new pre-release from 1 (check for minor)``
        ()
        =
        let settings = DefaultCommandSettings()

        let commits: Git.Commit list =
            [ Git.Commit.Create("49c0699af98a67f1e8efcac8b1467b283a244aa8", "fix: fix a bug") ]

        let commits: CommitForRelease list =
            [
                {
                    OriginalCommit = commits[0]
                    SemanticCommit =
                        Parser.tryParseCommitMessage CommitParserConfig.Default commits[0].RawBody
                        |> Result.valueOr failwith
                }
            ]

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata =
                    { ChangelogMetadata.Empty with
                        PreRelease = Some "alpha"
                    }
            }

        let actual =
            ReleaseContext.computeVersion
                settings
                changelogInfo
                commits
                (SemVersion(2, 2, 0).WithPrereleaseParsedFrom("beta.10"))

        Expect.equal actual (Some(SemVersion.ParsedFrom(2, 2, 0, "alpha.1")))

    [<Test>]
    member _.``If pre-release identifier is different start a new pre-release from 1 (check for patch)``
        ()
        =
        let settings = DefaultCommandSettings()

        let commits: Git.Commit list =
            [ Git.Commit.Create("49c0699af98a67f1e8efcac8b1467b283a244aa8", "fix: fix a bug") ]

        let commits: CommitForRelease list =
            [
                {
                    OriginalCommit = commits[0]
                    SemanticCommit =
                        Parser.tryParseCommitMessage CommitParserConfig.Default commits[0].RawBody
                        |> Result.valueOr failwith
                }
            ]

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata =
                    { ChangelogMetadata.Empty with
                        PreRelease = Some "alpha"
                    }
            }

        let actual =
            ReleaseContext.computeVersion
                settings
                changelogInfo
                commits
                (SemVersion(2, 2, 45).WithPrereleaseParsedFrom("beta.10"))

        Expect.equal actual (Some(SemVersion.ParsedFrom(2, 2, 45, "alpha.1")))

    [<Test>]
    member _.``Pre-release can be configured from CLI settings``() =
        let settings =
            DefaultCommandSettings(PreRelease = FlagValue(Value = "alpha", IsSet = true))

        let commits: Git.Commit list =
            [ Git.Commit.Create("49c0699af98a67f1e8efcac8b1467b283a244aa8", "fix: fix a bug") ]

        let commits: CommitForRelease list =
            [
                {
                    OriginalCommit = commits[0]
                    SemanticCommit =
                        Parser.tryParseCommitMessage CommitParserConfig.Default commits[0].RawBody
                        |> Result.valueOr failwith
                }
            ]

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata = ChangelogMetadata.Empty
            }

        let actual =
            ReleaseContext.computeVersion settings changelogInfo commits (SemVersion(2, 2, 45))

        Expect.equal actual (Some(SemVersion.ParsedFrom(2, 2, 46, "alpha.1")))

    [<Test>]
    member _.``If pre-release is configured both in CLI settings and changelog metadata, CLI settings should take precedence``
        ()
        =
        let settings =
            DefaultCommandSettings(PreRelease = FlagValue(Value = "alpha", IsSet = true))

        let commits: Git.Commit list =
            [ Git.Commit.Create("49c0699af98a67f1e8efcac8b1467b283a244aa8", "fix: fix a bug") ]

        let commits: CommitForRelease list =
            [
                {
                    OriginalCommit = commits[0]
                    SemanticCommit =
                        Parser.tryParseCommitMessage CommitParserConfig.Default commits[0].RawBody
                        |> Result.valueOr failwith
                }
            ]

        let changelogInfo =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(0, 0, 0) ]
                Metadata =
                    { ChangelogMetadata.Empty with
                        PreRelease = Some "beta"
                    }
            }

        let actual =
            ReleaseContext.computeVersion settings changelogInfo commits (SemVersion(2, 2, 45))

        Expect.equal actual (Some(SemVersion.ParsedFrom(2, 2, 46, "alpha.1")))

let inline private verifyChangelogAndExtraFile changelogPath extraFilePath =
    let changelogContent = File.ReadAllText(changelogPath)
    let extraFileContent = File.ReadAllText(extraFilePath)

    let content =
        $"""=== Changelog ===
{changelogContent}
=== Extra File ===
{extraFileContent}
"""

    Verifier.Verify(content)

type ReleaseContextApplyTests() =

    [<Test>]
    member _.``ReleaseContext.apply does nothing if no bump required``() =
        let remoteConfig =
            {
                Hostname = "github.com"
                Owner = "easybuild-org"
                Repository = "EasyBuild.ShipIt"
            }

        let releaseContext =
            {
                File = FileInfo(Workspace.``valid_changelog.md``)
                Content = STANDARD_CHANGELOG
                Versions = [ SemVersion(1, 0, 0) ]
                Metadata = ChangelogMetadata.Empty
            }
            |> NoVersionBumpRequired

        let result = ReleaseContext.apply remoteConfig releaseContext

        Expect.equal result (Ok())

    [<Test>]
    member _.``ReleaseContext.apply updating package.json works``() =
        task {
            let remoteConfig =
                {
                    Hostname = "github.com"
                    Owner = "easybuild-org"
                    Repository = "EasyBuild.ShipIt"
                }

            use _ = new RestorableFile(Workspace.``changelog_with_package-json_updater.md``)
            use _ = new RestorableFile(Workspace.files.``package.json``)

            let changelogInfo =
                Workspace.``changelog_with_package-json_updater.md``
                |> FileInfo
                |> Changelog.tryLoad
                |> _.UnsafeOkValue

            let releaseContext =
                {
                    NewVersion = SemVersion(52, 1, 0)
                    CommitsForRelease =
                        [
                            Git.Commit.Create(
                                "0b1899bb03d3eb86a30c84aa4c66c037527fbd14",
                                "feat: Add feature"
                            )
                            |> gitCommitToCommitForRelease
                            Git.Commit.Create(
                                "2a6f3b3403aaa629de6e65558448b37f126f8e86",
                                "feat: Add another feature"
                            )
                            |> gitCommitToCommitForRelease
                        ]
                    LastCommitSha = "0b1899bb03d3eb86a30c84aa4c66c037527fbd14"
                    Changelog = changelogInfo
                }
                |> BumpRequired

            let result = ReleaseContext.apply remoteConfig releaseContext

            Expect.isOk result

            return!
                verifyChangelogAndExtraFile
                    Workspace.``changelog_with_package-json_updater.md``
                    Workspace.files.``package.json``
        }

    [<Test>]
    member _.``ReleaseContext.apply updating JSON file with JSON Pointer works``() =
        task {
            let remoteConfig =
                {
                    Hostname = "github.com"
                    Owner = "easybuild-org"
                    Repository = "EasyBuild.ShipIt"
                }

            use _ = new RestorableFile(Workspace.``changelog_with_json_updater.md``)
            use _ = new RestorableFile(Workspace.files.``some_file.json``)

            let changelogInfo =
                Workspace.``changelog_with_json_updater.md``
                |> FileInfo
                |> Changelog.tryLoad
                |> _.UnsafeOkValue

            let releaseContext =
                {
                    NewVersion = SemVersion(3, 2, 1)
                    CommitsForRelease =
                        [
                            Git.Commit.Create(
                                "0b1899bb03d3eb86a30c84aa4c66c037527fbd14",
                                "feat: Add feature"
                            )
                            |> gitCommitToCommitForRelease
                            Git.Commit.Create(
                                "2a6f3b3403aaa629de6e65558448b37f126f8e86",
                                "feat: Add another feature"
                            )
                            |> gitCommitToCommitForRelease
                        ]
                    LastCommitSha = "0b1899bb03d3eb86a30c84aa4c66c037527fbd14"
                    Changelog = changelogInfo
                }
                |> BumpRequired

            let result = ReleaseContext.apply remoteConfig releaseContext

            Expect.isOk result

            let! _ =
                verifyChangelogAndExtraFile
                    Workspace.``changelog_with_json_updater.md``
                    Workspace.files.``some_file.json``

            return ()
        }

    [<Test>]
    member _.``ReleaseContext.apply updating XML file works``() =
        task {
            let remoteConfig =
                {
                    Hostname = "github.com"
                    Owner = "easybuild-org"
                    Repository = "EasyBuild.ShipIt"
                }

            use _ = new RestorableFile(Workspace.``changelog_with_xml_updater.md``)
            use _ = new RestorableFile(Workspace.files.``some_file.xml``)

            let changelogInfo =
                Workspace.``changelog_with_xml_updater.md``
                |> FileInfo
                |> Changelog.tryLoad
                |> _.UnsafeOkValue

            let releaseContext =
                {
                    NewVersion = SemVersion(5, 4, 3)
                    CommitsForRelease =
                        [
                            Git.Commit.Create(
                                "0b1899bb03d3eb86a30c84aa4c66c037527fbd14",
                                "feat: Add feature"
                            )
                            |> gitCommitToCommitForRelease
                            Git.Commit.Create(
                                "2a6f3b3403aaa629de6e65558448b37f126f8e86",
                                "feat: Add another feature"
                            )
                            |> gitCommitToCommitForRelease
                        ]
                    LastCommitSha = "0b1899bb03d3eb86a30c84aa4c66c037527fbd14"
                    Changelog = changelogInfo
                }
                |> BumpRequired

            let result = ReleaseContext.apply remoteConfig releaseContext

            Expect.isOk result

            return!
                verifyChangelogAndExtraFile
                    Workspace.``changelog_with_xml_updater.md``
                    Workspace.files.``some_file.xml``
        }

    [<Test>]
    member _.``ReleaseContext.apply updating using Regex works``() =
        task {
            let remoteConfig =
                {
                    Hostname = "github.com"
                    Owner = "easybuild-org"
                    Repository = "EasyBuild.ShipIt"
                }

            use _ = new RestorableFile(Workspace.``changelog_with_regex_updater.md``)
            use _ = new RestorableFile(Workspace.files.``some_file.txt``)

            let changelogInfo =
                Workspace.``changelog_with_regex_updater.md``
                |> FileInfo
                |> Changelog.tryLoad
                |> _.UnsafeOkValue

            let releaseContext =
                {
                    NewVersion = SemVersion(9, 8, 7)
                    CommitsForRelease =
                        [
                            Git.Commit.Create(
                                "0b1899bb03d3eb86a30c84aa4c66c037527fbd14",
                                "feat: Add feature"
                            )
                            |> gitCommitToCommitForRelease
                            Git.Commit.Create(
                                "2a6f3b3403aaa629de6e65558448b37f126f8e86",
                                "feat: Add another feature"
                            )
                            |> gitCommitToCommitForRelease
                        ]
                    LastCommitSha = "0b1899bb03d3eb86a30c84aa4c66c037527fbd14"
                    Changelog = changelogInfo
                }
                |> BumpRequired

            let result = ReleaseContext.apply remoteConfig releaseContext

            Expect.isOk result

            return!
                verifyChangelogAndExtraFile
                    Workspace.``changelog_with_regex_updater.md``
                    Workspace.files.``some_file.txt``
        }

    [<Test>]
    member _.``ReleaseContext.apply updating using command works``() =
        task {
            let remoteConfig =
                {
                    Hostname = "github.com"
                    Owner = "easybuild-org"
                    Repository = "EasyBuild.ShipIt"
                }

            use _ = new RestorableFile(Workspace.``changelog_with_command_updater.md``)
            use _ = new RestorableFile(Workspace.files.``some_file.version``)

            let changelogInfo =
                Workspace.``changelog_with_command_updater.md``
                |> FileInfo
                |> Changelog.tryLoad
                |> _.UnsafeOkValue

            let releaseContext =
                {
                    NewVersion = SemVersion(9, 8, 7)
                    CommitsForRelease =
                        [
                            Git.Commit.Create(
                                "0b1899bb03d3eb86a30c84aa4c66c037527fbd14",
                                "feat: Add feature"
                            )
                            |> gitCommitToCommitForRelease
                            Git.Commit.Create(
                                "2a6f3b3403aaa629de6e65558448b37f126f8e86",
                                "feat: Add another feature"
                            )
                            |> gitCommitToCommitForRelease
                        ]
                    LastCommitSha = "0b1899bb03d3eb86a30c84aa4c66c037527fbd14"
                    Changelog = changelogInfo
                }
                |> BumpRequired

            let result = ReleaseContext.apply remoteConfig releaseContext

            Expect.isOk result

            return!
                verifyChangelogAndExtraFile
                    Workspace.``changelog_with_command_updater.md``
                    Workspace.files.``some_file.version``
        }

    [<Test>]
    member _.``When force_version is set, it is not forwarded to generated changelog``() =
        task {
            let remoteConfig =
                {
                    Hostname = "github.com"
                    Owner = "easybuild-org"
                    Repository = "EasyBuild.ShipIt"
                }

            use _ = new RestorableFile(Workspace.``valid_changelog_with_forced_version.md``)

            let changelogInfo =
                Workspace.``valid_changelog_with_forced_version.md``
                |> FileInfo
                |> Changelog.tryLoad
                |> _.UnsafeOkValue

            let releaseContext =
                {
                    // Forcing to use the same version as the one resolved in the changelog
                    NewVersion = changelogInfo.Metadata.ForceVersion.Value
                    CommitsForRelease =
                        [
                            Git.Commit.Create(
                                "0b1899bb03d3eb86a30c84aa4c66c037527fbd14",
                                "feat: Add feature"
                            )
                            |> gitCommitToCommitForRelease
                            Git.Commit.Create(
                                "2a6f3b3403aaa629de6e65558448b37f126f8e86",
                                "feat: Add another feature"
                            )
                            |> gitCommitToCommitForRelease
                        ]
                    LastCommitSha = "0b1899bb03d3eb86a30c84aa4c66c037527fbd14"
                    Changelog = changelogInfo
                }
                |> BumpRequired

            let result = ReleaseContext.apply remoteConfig releaseContext

            Expect.isOk result

            return!
                verifyChangelogAndExtraFile
                    Workspace.``valid_changelog_with_forced_version.md``
                    // The file below is provided even if it is not updated by the changelog above
                    // This is just because the argument is required
                    Workspace.files.``empty.txt``
        }
